这是一个非常好的问题，它触及了合作式执行器和抢占式执行器在中断处理上的根本区别。

在 **Embassy 默认的合作式**多任务环境下：

**不，ISR 返回时回到执行器的调度点，并不意味着先前正在运行的任务被“抢占”（preempted）了。**

这里需要区分两个概念：

1.  **硬件中断 (Hardware Interrupt):** 这是由外设（如定时器、UART、DMA）或 CPU 内部事件触发的，是强制性的。当硬件中断发生时，CPU 会立即暂停当前正在执行的任何代码（无论是应用程序任务代码还是执行器代码），保存当前状态，然后跳转到对应的中断服务程序 (ISR) 执行。这是一个强制性的暂停。
2.  **调度器抢占 (Scheduler Preemption):** 这是由操作系统或执行器的调度器决定的。在一个**抢占式**多任务系统中，调度器可以根据任务的优先级或时间片等策略，在任何时候（除了少数原子操作期间）中断当前正在运行的任务，强制切换到另一个就绪的任务，即使当前任务没有主动让出 CPU。

**在 Embassy 的合作式模型中：**

* ISR 返回时，控制权确实会回到执行器的一个调度点。这个调度点使得执行器有机会在 CPU 回到被中断的代码之前运行。
* 在这个调度点，执行器会检查是否有任务因为刚才发生的中断而变得就绪（因为 ISR 调用了 `waker.wake()`）。
* **然而，** 如果被中断的任务**不是**在 `.await` 点被中断的（也就是说，它正在执行常规的代码，包括陷入了 `blocking_read` 这样的阻塞函数内部），合作式执行器**不会**仅仅因为有其他任务就绪就强制停止并切换到另一个任务。它会把控制权**还给原来被中断的那个任务**，让它继续从中断发生的地方执行。
* 只有当被中断的任务**恰好**是在一个 `.await` 点等待，或者它刚刚从一个 `.await` 调用返回，并且有其他任务也已经就绪时，执行器才会选择切换到另一个任务。

**简而言之：**

ISR 强制中断了当前任务的执行，但 ISR 返回后，默认的合作式执行器会**尝试回到被中断的任务**，除非那个任务已经完成或者在一个 `.await` 点自愿让出了 CPU。ISR 返回点是执行器检查**就绪状态**并决定**下一个**运行哪个任务的机会，但这不代表它可以**随意中断**正在非让出状态运行的任务。

`blocking_read` 的问题就在于，它让任务陷入了一个不包含 `.await` 的等待状态，所以它**不会**在中断返回后让出 CPU 控制权给执行器去调度其他任务，从而“霸占”了 CPU。

您描述的“控制权不会直接简单地回到中断发生时的那条指令。而是会回到执行器的主循环或一个负责重新调度的点”这个机制，在抢占式系统中，正被用来实现真正的调度器抢占；而在合作式系统中，它被用来确保在中断返回后，执行器有机会立即看到新就绪的任务，并在合适的时机（当下个 `.await` 发生时）进行任务切换。